
import io
import os
import collections
import asyncio
from typing import Dict, List

from fastapi import FastAPI, File, Form, UploadFile, Depends, HTTPException
from fastapi.responses import HTMLResponse, StreamingResponse
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware

from llm_detect.settings import settings

description = """
## Introduction

Find out whether a text has been generated by an AI system.

## Use case
- Interactive front-end (built with gradio).
- Batch processing

"""

app = FastAPI(
    title='AI Detect',
    description=description,
    summary='AI Detection Service',
    version='0.0.1')

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"])

# Mount the static directory to serve the HTML file
app.mount("/static", StaticFiles(directory="static"), name="static")


def process_data(text):
    import time
    print("sleeping")
    time.sleep(10)
    return text.upper()


class FileUploadManager:
    def __init__(self) -> None:
        self.file_chunks: Dict[str, Dict[int, bytes]] = collections.defaultdict(dict)
        self.locks: Dict[str, asyncio.Lock] = collections.defaultdict(asyncio.Lock)
        self.processed_files: Dict[str, bytes] = {}
        self.filenames: Dict[str, str] = {}

    async def add_chunk(self, session_id: str, filename: str, chunk_number: int, chunk_data: bytes):
        async with self.locks[session_id]:
            self.file_chunks[session_id][chunk_number] = chunk_data
            if filename in self.filenames:
                raise ValueError
            self.filenames[session_id] = filename

    async def process_file_if_ready(self, session_id: str, total_chunks: int):
        async with self.locks[session_id]:
            if len(self.file_chunks[session_id]) == total_chunks:
                file_data = b''.join(self.file_chunks[session_id][i] for i in range(total_chunks))
                processed_data = process_data(file_data)
                self.processed_files[session_id] = processed_data
                del self.file_chunks[session_id]
                return True
            else:
                return False
            
    async def check_processed_file_status(self, session_id: str):
        return self.processed_files.get(session_id, None)
            
    async def get_processed_file(self, session_id: str):
        async with self.locks[session_id]:
            processed_file = self.processed_files[session_id]
            filename = self.filenames[session_id]
            del self.locks[session_id]
            del self.filenames[session_id]
            return {'filename': filename, 'processed_file': processed_file}

            
file_upload_manager = FileUploadManager()


@app.get("/", response_class=HTMLResponse)
async def read_index():
    with open("static/index.html") as f:
        html_content = f.read()
    return HTMLResponse(content=html_content)


@app.post("/upload")
async def upload(file: UploadFile = File(...),
                 chunk: int = Form(...), 
                 total_chunks: int = Form(...),
                 session_id: str = Form(...),
                 manager: FileUploadManager = Depends(lambda: file_upload_manager)):
    
    print(f"Received chunk {chunk + 1}/{total_chunks} of file: {file.filename}")

    await manager.add_chunk(session_id, file.filename, chunk, await file.read())

    if await manager.process_file_if_ready(session_id, total_chunks):
        return {"message": f"File {file.filename} uploaded and processed."}
    else:
        return {"message": f"Chunk {chunk + 1}/{total_chunks} received."}


@app.get("/processing-status")
async def get_processing_status(session_id: str, 
                                manager: FileUploadManager = Depends(lambda: file_upload_manager)):
    if manager.check_processed_file_status(session_id):
        return {"status": "done"}
    else:
        return {"status": "processing"}


@app.get("/download-file")
async def download_file(session_id: str,
                        manager: FileUploadManager = Depends(lambda: file_upload_manager)):
    payload = await manager.get_processed_file(session_id)
    if payload:
        return StreamingResponse(io.BytesIO(payload['processed_file']), 
                                 media_type='application/octet-stream', 
                                 headers={"Content-Disposition": f"attachment; filename={payload['filename']}"})
    else:
        raise HTTPException(status_code=404, detail=f"File not found")


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--debug', action='store_true')
    args = parser.parse_args()

    import uvicorn
    uvicorn.run("app:app",
                host='0.0.0.0',
                port=settings.PORT,
                reload=args.debug,
                workers=3)
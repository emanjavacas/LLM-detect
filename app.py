
import io
import logging
import collections
import asyncio
import time
from concurrent.futures import ProcessPoolExecutor
from contextlib import asynccontextmanager, contextmanager
from typing import Dict

from fastapi import FastAPI, File, Form, UploadFile
from fastapi import WebSocket, WebSocketDisconnect
from fastapi import Depends, HTTPException, BackgroundTasks
from fastapi.responses import HTMLResponse, StreamingResponse
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware

import gradio as gr

from llm_detect.settings import settings
# from llm_detect.interface_highlighted import demo as highlighted_demo
# from llm_detect.interface import demo as simple_demo
# from llm_detect.models import load_model


logger = logging.getLogger(__name__)
logging.basicConfig(
    format='%(asctime)s %(levelname)-8s %(message)s',
    level=logging.DEBUG,
    datefmt='%Y-%m-%d %H:%M:%S')


@contextmanager
def running_time(prefix="", level=logging.INFO):
    start = time.time()
    yield
    took = (prefix + ": " if prefix else "") + f"Took {time.time() - start:.4} second(s)"
    if level == logging.INFO:
        logger.info(took)
    elif level == logging.DEBUG:
        logger.debug(took)


description = """
## Introduction

Find out whether a text has been generated by an AI system.

## Use case
- Interactive front-end (built with gradio)
- Upload file system
"""

async def run_in_process(executor, fn, *args, **kwargs):
    loop = asyncio.get_event_loop()
    return await loop.run_in_executor(executor, fn, *args, **kwargs)


def process_data(model, text):
    scores = model.score(text, return_token_scores=False)
    return scores


class WebSocketManager:
    def __init__(self) -> None:
        self.websockets: Dict[str, WebSocket] = {}
        self.lock = asyncio.Lock()

    def log_available_websocket(self):
        logger.info("Available sessions:\n" + "\n".join(f" - {key}" for key in self.websockets))

    async def register(self, session_id: str, websocket: WebSocket):
        async with self.lock:
            logger.info(f"Registration for: {session_id}")
            self.websockets[session_id] = websocket
            self.log_available_websocket()
    
    async def deregister(self, session_id: str):
        async with self.lock:
            if session_id in self.websockets:
                logger.info(f"Deregistration for: {session_id}")
                del self.websockets[session_id]

    async def notify(self, session_id: str, status: str):
        async with self.lock:
            self.log_available_websocket()
            if session_id in self.websockets:
                ws = self.websockets[session_id]
                try:
                    logger.info(f"Session {session_id}: status '{status}'")
                    await ws.send_json({"status": status})
                except WebSocketDisconnect:
                    logger.info(f"Session {session_id}: disconnect")
                    await self.deregister(session_id)
            else:
                logger.info(f"Notification to unknown session: {session_id}")
                self.log_available_websocket()


class FileUploadManager:
    def __init__(self, app_state) -> None:
        self.file_chunks: Dict[str, Dict[int, bytes]] = collections.defaultdict(dict)
        self.processed_files: Dict[str, bytes] = {}
        self.filenames: Dict[str, str] = {}
        self.app_state = app_state

    def add_chunk(self, session_id: str, filename: str, chunk_number: int, chunk_data: bytes):
        self.file_chunks[session_id][chunk_number] = chunk_data
        if session_id not in self.filenames:
            self.filenames[session_id] = filename

    async def process_file_if_ready(self, session_id: str, total_chunks: int):
        if len(self.file_chunks[session_id]) == total_chunks:
            file_data = b''.join(self.file_chunks[session_id][i] for i in range(total_chunks))
            del self.file_chunks[session_id]
            try:
                processed_data = process_data(self.app_state.model, file_data)
                # processed_data = await run_in_process(
                    # self.app_state.executor, process_data, self.app_state.model, file_data)
                self.processed_files[session_id] = processed_data
                await self.app_state.websocket_manager.notify(session_id, "done")
            except Exception as e:
                logger.info(f"Session {session_id}: error - {str(e)}")
                await self.app_state.websocket_manager.notify(session_id, "error")
            
    def get_processed_file(self, session_id: str):
        processed_file = self.processed_files[session_id]
        filename = self.filenames[session_id]
        del self.filenames[session_id]
        del self.processed_files[session_id]
        return {'filename': filename, 'processed_file': processed_file}


@asynccontextmanager
async def lifespan(app: FastAPI):
    logger.info("Starting model")
    # app.state.model = await load_model()
    app.state.model = None
    logger.info("Loaded model")
    app.state.file_upload_manager = FileUploadManager(app.state)
    app.state.websocket_manager = WebSocketManager()
    # app.state.executor = ProcessPoolExecutor()
    yield
    del app.state.file_upload_manager
    del app.state.websocket_manager
    del app.state.model
    # app.state.executor.shutdown()

app = FastAPI(
    title='AI Detect',
    description=description,
    summary='AI Detection Service',
    version='0.0.1',
    lifespan=lifespan)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"])


@app.get("/", response_class=HTMLResponse)
async def read_index():
    with open("static/index.html") as f:
        html_content = f.read()
    return HTMLResponse(content=html_content)


@app.websocket("/ws/{session_id}")
async def websocket(websocket: WebSocket, session_id: str):
    logger.info(f"Session {session_id}: WebSocket connection initiated.")
    await websocket.accept()
    await app.state.websocket_manager.register(session_id, websocket)
    try:
        while True:
            await websocket.receive_text()
    except WebSocketDisconnect:
        await app.state.websocket_manager.deregister(session_id)
    except Exception as e:
        logger.error(f"Session {session_id}: Error in WebSocket")
        await app.state.websocket_manager.deregister(session_id)


@app.post("/upload")
async def upload(file: UploadFile = File(...),
                 chunk: int = Form(...), 
                 total_chunks: int = Form(...),
                 session_id: str = Form(...),
                 background_tasks: BackgroundTasks = BackgroundTasks()):

    msg = f"Received chunk {chunk + 1}/{total_chunks} of file: {file.filename}"
    logger.info(f"Session {session_id}: {msg}")
    chunk_data = await file.read()
    app.state.file_upload_manager.add_chunk(session_id, file.filename, chunk, chunk_data)
    if chunk == total_chunks - 1:
        background_tasks.add_task(
            app.state.file_upload_manager.process_file_if_ready, session_id, total_chunks)
    return {"message": msg}


@app.get("/download-file")
async def download_file(session_id: str):
    payload = app.state.file_upload_manager.get_processed_file(session_id)
    if payload:
        return StreamingResponse(io.BytesIO(payload['processed_file']), 
                                 media_type='application/octet-stream', 
                                 headers={"Content-Disposition": f"attachment; filename={payload['filename']}"})
    else:
        raise HTTPException(status_code=404, detail=f"File not found")
    

# Mount the static directory to serve the HTML file
app.mount("/static", StaticFiles(directory="static"), name="static")
# # Mount the gradio apps
# app = gr.mount_gradio_app(app, highlighted_demo, path="/gradio/highlight/")
# app = gr.mount_gradio_app(app, simple_demo, path="/gradio/simple/")


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--debug', action='store_true')
    args = parser.parse_args()
        
    import uvicorn
    uvicorn.run("app:app",
                host='0.0.0.0',
                port=settings.PORT,
                reload=args.debug,
                workers=3)

import os
import io
import logging
import collections
import asyncio
import time
from concurrent.futures import ProcessPoolExecutor
from contextlib import asynccontextmanager, contextmanager
from typing import Dict

from fastapi import FastAPI, File, Form, UploadFile, Request
from fastapi import WebSocket, WebSocketDisconnect
from fastapi import HTTPException, BackgroundTasks
from fastapi.responses import StreamingResponse, HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware
from fastapi.templating import Jinja2Templates

import gradio as gr
import pandas as pd

from llm_detect.settings import settings, STATUS
from llm_detect.interface_highlighted import demo as highlighted_demo
from llm_detect.interface import demo as simple_demo
from llm_detect.models import MODEL


logger = logging.getLogger(__name__)
logging.basicConfig(
    format='%(asctime)s %(levelname)-8s %(message)s',
    level=logging.DEBUG,
    datefmt='%Y-%m-%d %H:%M:%S')


@contextmanager
def running_time(prefix="", level=logging.INFO):
    start = time.time()
    yield
    took = (prefix + ": " if prefix else "") + f"Took {time.time() - start:.4} second(s)"
    if level == logging.INFO:
        logger.info(took)
    elif level == logging.DEBUG:
        logger.debug(took)


description = """
## Introduction

Find out whether a text has been generated by an AI system.

## Use case
- Interactive front-end (built with gradio)
- Upload file system
"""


class WebSocketManager:
    def __init__(self) -> None:
        self.websockets: Dict[str, WebSocket] = {}
        self.lock = asyncio.Lock()

    def log_available_websocket(self):
        users = "\n".join(f" - {key}" for key in self.websockets)
        logger.info("Available users:" + " -" if not users else ("\n" + users))

    async def register(self, user_id: str, websocket: WebSocket):
        async with self.lock:
            logger.info(f"Registration for: {user_id}")
            self.websockets[user_id] = websocket
            self.log_available_websocket()
    
    async def deregister(self, user_id: str):
        async with self.lock:
            if user_id in self.websockets:
                logger.info(f"Deregistration for: {user_id}")
                del self.websockets[user_id]

    async def notify(self, user_id: str, session_id: str, status: str):
        async with self.lock:
            self.log_available_websocket()
            if user_id in self.websockets:
                ws = self.websockets[user_id]
                try:
                    logger.info(f"User '{user_id}', session '{session_id}': status '{status}'")
                    await ws.send_json({"status": status, "sessionId": session_id})
                except WebSocketDisconnect:
                    logger.info(f"User '{user_id}': disconnect")
                    await self.deregister(user_id)
            else:
                logger.info(f"Notification to unknown user: {user_id}")


async def run_in_process(executor, fn, *args, **kwargs):
    loop = asyncio.get_event_loop()
    return await loop.run_in_executor(executor, fn, *args, **kwargs)


class ValidationException(Exception):
    pass


def validate_file(file_data):
    try:
        data = pd.read_csv(io.StringIO(file_data.decode()))
        if len(data) == 0:
            raise ValidationException({"status": STATUS.EMPTYFILE})
        if "text" not in data:
            raise ValidationException({"status": STATUS.MISSINGKEY})
        return data
    except UnicodeDecodeError:
        raise ValidationException({"status": STATUS.UNKNOWNFORMAT})


def process_data(file_data):
    # validation
    file_data = validate_file(file_data)
    # prediction
    output = []
    for _, row in file_data.iterrows():
        row = row.to_dict()
        row['score'] = MODEL.model.score(row['text'])
        output.append(row)
    # post-processing
    output = pd.DataFrame.from_dict(output).to_csv(index=None)
    return output


class FileUploadManager:
    def __init__(self, app_state) -> None:
        self.file_chunks: Dict[str, Dict[int, bytes]] = collections.defaultdict(dict)
        self.processed_files: Dict[str, bytes] = {}
        self.filenames: Dict[str, str] = {}
        self.app_state = app_state

    def add_chunk(self, session_id: str, filename: str, chunk_number: int, chunk_data: bytes):
        self.file_chunks[session_id][chunk_number] = chunk_data
        if session_id not in self.filenames:
            self.filenames[session_id] = filename

    async def process_file_if_ready(self, user_id: str, session_id: str, total_chunks: int):
        if len(self.file_chunks[session_id]) == total_chunks:
            file_data = b''.join(self.file_chunks[session_id][i] for i in range(total_chunks))
            try:
                # processed_data = await run_in_process(
                #     self.app_state.executor, process_data, file_data=file_data)
                processed_data = process_data(file_data)
                self.processed_files[session_id] = processed_data
                await self.app_state.websocket_manager.notify(user_id, session_id, STATUS.READY)
                del self.file_chunks[session_id]
            except ValidationException as e:
                logger.info(f"Session {session_id}: validation exception - {str(e)}")
                await self.app_state.websocket_manager.notify(user_id, session_id, e.args[0]['status'])
            except Exception as e:
                logger.info(f"Session {session_id}: error - {str(e)}")
                await self.app_state.websocket_manager.notify(user_id, session_id, STATUS.UNKNOWNERROR)
            
    def get_processed_file(self, session_id: str):
        processed_file = self.processed_files[session_id]
        filename = self.filenames[session_id]
        filename, _ = os.path.splitext(filename)
        filename += ".LLMDetect.csv"
        del self.filenames[session_id]
        del self.processed_files[session_id]
        return {'filename': filename, 'processed_file': processed_file}


@asynccontextmanager
async def lifespan(app: FastAPI):
    app.state.file_upload_manager = FileUploadManager(app.state)
    app.state.websocket_manager = WebSocketManager()
    app.state.executor = ProcessPoolExecutor()
    yield
    del app.state.file_upload_manager
    del app.state.websocket_manager
    app.state.executor.shutdown()

app = FastAPI(
    title='AI Detect',
    description=description,
    summary='AI Detection Service',
    version='0.0.1',
    lifespan=lifespan)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"])


templates = Jinja2Templates(directory="static")

@app.get("/", response_class=HTMLResponse)
async def read_index(request: Request):
    return templates.TemplateResponse(
        "index.html", {"request": request, "statuses": STATUS.__get_classes__()})


@app.websocket("/ws/{user_id}")
async def websocket(websocket: WebSocket, user_id: str):
    logger.info(f"Session {user_id}: WebSocket connection initiated.")
    await websocket.accept()
    await app.state.websocket_manager.register(user_id, websocket)
    try:
        while True:
            await websocket.receive_text()
    except WebSocketDisconnect:
        await app.state.websocket_manager.deregister(user_id)
    except Exception as e:
        logger.error(f"Session {user_id}: Error in WebSocket")
        await app.state.websocket_manager.deregister(user_id)


@app.post("/upload")
async def upload(file: UploadFile = File(...),
                 chunk: int = Form(...), 
                 total_chunks: int = Form(...),
                 user_id: str = Form(...),
                 session_id: str = Form(...),
                 background_tasks: BackgroundTasks = BackgroundTasks()):

    msg = f"Received chunk {chunk + 1}/{total_chunks} of file: {file.filename}"
    logger.info(f"Session {session_id}: {msg}")
    app.state.file_upload_manager.add_chunk(session_id, file.filename, chunk, await file.read())
    if chunk == total_chunks - 1:
        background_tasks.add_task(
            app.state.file_upload_manager.process_file_if_ready, user_id, session_id, total_chunks)
    return {"message": msg}


@app.get("/download-file")
async def download_file(session_id: str):
    payload = app.state.file_upload_manager.get_processed_file(session_id)
    if payload:
        return StreamingResponse(io.BytesIO(payload['processed_file'].encode()),
                                 media_type='application/octet-stream',
                                 headers={"Content-Disposition": f"attachment; filename={payload['filename']}"})
    else:
        raise HTTPException(status_code=404, detail=f"File not found")
    

MODEL.load()
# Mount the static directory to serve the HTML file
app.mount("/static", StaticFiles(directory="static"), name="static")
# Mount the gradio apps
app = gr.mount_gradio_app(app, highlighted_demo, path="/gradio/highlight/")
app = gr.mount_gradio_app(app, simple_demo, path="/gradio/simple/")


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('--debug', action='store_true')
    args = parser.parse_args()
        
    import uvicorn
    uvicorn.run("app:app",
                host='0.0.0.0',
                port=settings.PORT,
                # workers=3,
                reload=args.debug)